var ShaderLibrary = {
  get: function(e) {
    return ShaderLibrary.getInclude("include_common") + ShaderLibrary.getInclude("include_sph") + ShaderLibrary[e + ".glsl"]
  },
  getInclude: function(e) {
    return ShaderLibrary[e + ".glsl"] + "\n"
  }
}

ShaderLibrary["distance_functions.glsl"] = "// IÃ±igo Quilez's distance functions: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat signedDistanceBox(vec3 pos, vec3 halfExtent)\n{\n    vec3 d = abs(pos) - halfExtent;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d, 0.0));\n}\n\n// same as box, but inverted\nfloat signedDistanceWalls(vec3 pos, vec3 halfExtent)\n{\n    return -signedDistanceBox(pos, halfExtent);\n}\n\nfloat signedDistanceSphere(vec3 p, vec3 c, float r)\n{\n  return distance(p, c) - r;\n}",
  ShaderLibrary["include_common.glsl"] = "vec4 encodeHDRE(vec3 color)\n{\n#ifdef HDRE\n    float maxValue = max(max(color.r, color.g), color.b) + .01;\n    float e = floor(max(log(maxValue), 0.0));\n    color /= exp(e);\n    return vec4(color, e / 5.0);\n#else\n    return vec4(color, 1.0);\n#endif\n}\n\nvec3 decodeHDRE(vec4 hdre)\n{\n#ifdef HDRE\n    float e = hdre.a * 5.0;\n    hdre.xyz *= exp(e);\n    return hdre.xyz;\n#else\n    return hdre.xyz;\n#endif\n}\n\nfloat luminance(vec3 color)\n{\n    return dot(color, vec3(.30, 0.59, .11));\n}\n\nfloat luminance(vec4 color)\n{\n    return luminance(color.xyz);\n}\n\nfloat linearStep(float lower, float upper, float x)\n{\n    return clamp((x - lower) / (upper - lower), 0.0, 1.0);\n}\n\n// Only for 0 - 1\nvec4 floatToRGBA8(float value)\n{\n    vec4 enc = value * vec4(1.0, 255.0, 65025.0, 16581375.0);\n    // cannot fract first value or 1 would not be encodable\n    enc.yzw = fract(enc.yzw);\n    return enc - enc.yzww * vec4(1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n}\n\nfloat RGBA8ToFloat(vec4 rgba)\n{\n    return dot(rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0));\n}\n\nvec2 floatToRG8(float value)\n{\n    vec2 enc = vec2(1.0, 255.0) * value;\n    enc.y = fract(enc.y);\n    enc.x -= enc.y / 255.0;\n    return enc;\n}\n\nfloat RG8ToFloat(vec2 rg)\n{\n    return dot(rg, vec2(1.0, 1.0/255.0));\n}\n\nvec3 intersectCubeMap(vec3 rayOrigin, vec3 rayDir, float cubeSize)\n{\n    vec3 t = (cubeSize * sign(rayDir) - rayOrigin) / rayDir;\n    float minT = min(min(t.x, t.y), t.z);\n    return rayOrigin + minT * rayDir;\n}",
  ShaderLibrary["bilat_gaussian_blur_fragment.glsl"] = "uniform sampler2D tDiffuse;\n\nvarying vec2 vUv;\n\nuniform vec2 sampleStep;\nuniform float weights[NUM_WEIGHTS];\nuniform float depthRange;\n\nfloat getWeight(float depth, float refDepth, float baseWeight)\n{\n//    return abs(refDepth - depth) < depthRange? baseWeight: 0.0;\n    float diff = abs(refDepth - depth) / depthRange;\n    float weight = max(1.0 - diff, 0.0);\n//    weight = pow(weight, .001);\n    return baseWeight * weight;\n}\n\nvoid main()\n{\n    float total = weights[0];\n    float center = RGBA8ToFloat(texture2D(tDiffuse, vUv));\n    float val = center * weights[0];\n\n    for (int i = 1; i <= KERNEL_RADIUS; ++i) {\n        vec2 offset = float(i) * sampleStep;\n        float samp = RGBA8ToFloat(texture2D(tDiffuse, vUv + offset));\n        float weight = getWeight(samp, center, weights[i]);\n        val += samp * weight;\n        total += weight;\n\n        samp = RGBA8ToFloat(texture2D(tDiffuse, vUv - offset));\n        weight = getWeight(samp, center, weights[i]);\n        val += samp * weight;\n        total += weight;\n    }\n\n    gl_FragColor = floatToRGBA8(val / total);\n}\n",
  ShaderLibrary["gaussian_blur_enc_float_fragment.glsl"] = "uniform sampler2D tDiffuse;\n\nvarying vec2 vUv;\n\nuniform vec2 sampleStep;\nuniform float weights[NUM_WEIGHTS];\n\nvoid main()\n{\n    vec3 col = decodeHDRE(texture2D(tDiffuse, vUv)) * weights[0];\n\n    for (int i = 1; i <= KERNEL_RADIUS; ++i) {\n        vec2 offset = float(i) * sampleStep;\n        col += (decodeHDRE(texture2D(tDiffuse, vUv + offset)) + decodeHDRE(texture2D(tDiffuse, vUv - offset))) * weights[i];\n    }\n\n    gl_FragColor = encodeHDRE(col);\n}\n",
  ShaderLibrary["gaussian_blur_fragment.glsl"] = "uniform sampler2D tDiffuse;\n\nvarying vec2 vUv;\n\nuniform vec2 sampleStep;\nuniform float weights[NUM_WEIGHTS];\n\nvoid main()\n{\n    vec4 val = texture2D(tDiffuse, vUv) * weights[0];\n\n    for (int i = 1; i <= KERNEL_RADIUS; ++i) {\n        vec2 offset = float(i) * sampleStep;\n        val += (texture2D(tDiffuse, vUv + offset) + texture2D(tDiffuse, vUv - offset)) * weights[i];\n    }\n\n    gl_FragColor = val;\n}\n",
  ShaderLibrary["post_vertex.glsl"] = "varying vec2 vUv;\n\nvoid main()\n{\n    gl_Position = vec4(position, 1.0);\n    vUv = uv;\n}\n",
  ShaderLibrary["post_z_vertex.glsl"] = "varying vec2 texCoords;\nvarying vec3 viewVector;\n\nuniform mat4 unprojectionMatrix;\n\nvoid main()\n{\n    gl_Position = vec4(position, 1.0);\n    texCoords = uv;\n    vec4 unproj = unprojectionMatrix * vec4(position.xy, 0.0, 1.0);\n    unproj /= unproj.w;\n    viewVector = -unproj.xyz / unproj.z;\n}\n",
  ShaderLibrary["debug_alpha_fragment.glsl"] = "varying vec2 texCoords;\nuniform sampler2D map;\n\nvoid main() {\n    vec4 samp = texture2D(map, texCoords);\n    gl_FragColor = vec4(samp.www, 1.0);\n}\n",
  ShaderLibrary["debug_alpha_vertex.glsl"] = "varying vec2 texCoords;\n\nvoid main() {\n    vec3 localPos = position;\n    vec4 viewPos = modelViewMatrix * vec4(localPos, 1.0);\n    gl_Position = projectionMatrix * viewPos;\n    texCoords = uv;\n}",
  ShaderLibrary["debug_vec3_fragment.glsl"] = "varying vec2 texCoords;\nuniform sampler2D map;\n\nvoid main() {\n    vec4 samp = texture2D(map, texCoords);\n    gl_FragColor = vec4(samp.xyz /** .5 + .5*/, 1.0);\n}\n",
  ShaderLibrary["debug_vec3_vertex.glsl"] = "varying vec2 texCoords;\n\nvoid main() {\n    vec3 localPos = position;\n    vec4 viewPos = modelViewMatrix * vec4(localPos, 1.0);\n    gl_Position = projectionMatrix * viewPos;\n    texCoords = uv;\n}",
  ShaderLibrary["dielectric_fragment.glsl"] = "#define MIN_VARIANCE -0.0001\n#define LIGHT_BLEED_REDUCTION .5\n\nvarying vec3 worldPosition;\nvarying vec3 viewPosition;\nvarying vec3 worldNormal;\n\n#if defined(SSAO_MAP) || defined(ALBEDO_MAP) || defined(NORMAL_MAP) || defined(ROUGHNESS_MAP) || defined(EMISSION_MAP)\nvarying vec2 texCoords;\n#endif\n\n#ifdef SSAO_MAP\nvarying vec4 projection;\nuniform sampler2D ssaoMap;\n#endif\n\nuniform float shadowMapSize;\nuniform float shadowMapPixelSize;\n\n#ifdef SHADOW_MAP\nuniform sampler2D shadowMap;\n\nvarying vec4 shadowCoord;\n\n#ifdef PCF_SHADOW_MAP\nuniform vec2 shadowOffsets[NUM_SHADOW_SAMPLES]; // w contains bias\n#endif\n#endif\n\n\n#ifdef ALBEDO_MAP\nuniform sampler2D albedoMap;\n\n#ifdef ALBEDO_MAP_2\nuniform sampler2D albedoMap2;\nuniform float albedoBlend;\n#endif\n\n#endif\n\nuniform vec3 color;\n\nuniform float roughness;\nuniform float normalSpecularReflection;\n\n#ifdef NORMAL_MAP\nuniform sampler2D normalMap;\n#endif\n\n#ifdef ROUGHNESS_MAP\nuniform sampler2D roughnessMap;\nuniform float roughnessMapRange;\n#endif\n\n#ifdef EMISSION_MAP\nuniform sampler2D emissionMap;\n#endif\n\nuniform vec3 emissionColor;\n\n#ifdef AMBIENT_OCCLUSION_MAP\nuniform sampler2D aoMap;\nvarying vec2 texCoords2;\n#endif\n\n#ifdef LOCAL_SKYBOX\n// this could also be applied to irradiance map\nuniform vec3 skyboxPosition;\nuniform float skyboxSize;\n#endif\n\n#ifdef SPECULAR_PROBE\nuniform samplerCube specularProbe;\nuniform vec3 specularProbeColor;\n#endif\n\n#ifdef FOG_PROBE\nuniform samplerCube fogProbe;\nuniform float fogProbeBoost;\n#endif\n\n#ifdef IRRADIANCE_PROBE\nuniform samplerCube irradianceProbe;\nuniform float irradianceProbeBoost;\n#endif\n\n// internal\nuniform vec3 ambientLightColor;\n\nuniform float alpha;\n\n#ifdef FOG\nuniform float fogDensity;\nuniform vec3 fogColor;\n#endif\n\n#if NUM_POINT_LIGHTS > 0\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float distance;\n    float decay;\n    int shadow;\n    float shadowBias;\n    float shadowRadius;\n    vec2 shadowMapSize;\n};\n\nuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n#endif\n\n#if NUM_DIR_LIGHTS > 0\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n    int shadow;\n    float shadowBias;\n    float shadowRadius;\n    vec2 shadowMapSize;\n};\nuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n#endif\n\n#ifdef NORMAL_MAP\nvec3 perturbNormal2Arb(vec3 position, vec3 worldNormal, vec3 normalSample)\n{\n    vec3 q0 = dFdx( position.xyz );\n    vec3 q1 = dFdy( position.xyz );\n    vec2 st0 = dFdx( texCoords.st );\n    vec2 st1 = dFdy( texCoords.st );\n    vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n    vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n    vec3 N = normalize( worldNormal );\n    mat3 tsn = mat3( S, T, N );\n    return normalize( tsn * normalSample );\n}\n#endif\n\nvec3 getNormal()\n{\n#if defined(NORMAL_MAP)\n    vec4 normalSample = texture2D( normalMap, texCoords );\n    vec3 normal = normalSample.xyz * 2.0 - 1.0;\n    #ifdef OBJECT_NORMALS\n    return normalize(normal);\n    #endif\n    return perturbNormal2Arb(worldPosition, worldNormal, normal);\n#else\n    #ifdef FACE_NORMALS\n        vec3 q0 = dFdx( worldPosition.xyz );\n        vec3 q1 = dFdy( worldPosition.xyz );\n        return normalize(cross(q0, q1));\n    #else\n        return normalize(worldNormal);\n    #endif\n#endif\n}\n\n#ifdef VSM_SHADOW_MAP\nvec2 getVSMMoments(vec2 uv)\n{\n    vec4 s = texture2D(shadowMap, uv);\n    #ifdef VSM_FLOAT\n    return s.xy;\n    #else\n    return vec2(RG8ToFloat(s.xy), RG8ToFloat(s.zw));\n    #endif\n}\n#endif\n\nfloat getShadow() {\n#ifdef SHADOW_MAP\n\n    #ifdef PCF_SHADOW_MAP\n        #if NUM_SHADOW_SAMPLES > 1\n        float shadow = 0.0;\n        for (int i = 0; i < NUM_SHADOW_SAMPLES; ++i) {\n            // pseudo random\n            #ifdef DITHER_SHADOW\n            float angle = fract (sin((gl_FragCoord.x + 0.5) * (gl_FragCoord.y + 1.0)) * 43758.5453123) * 3.1415 * 2.0;\n            float c = cos(angle);\n            float s = sin(angle);\n            vec2 offset;\n            offset.x = c * shadowOffsets[i].x - s * shadowOffsets[i].y;\n            offset.y = s * shadowOffsets[i].x + c * shadowOffsets[i].y;\n            #else\n            vec2 offset = shadowOffsets[i];\n            #endif\n\n            float occlDepth = RGBA8ToFloat(texture2D(shadowMap, shadowCoord.xy + offset));\n            float diff = shadowCoord.z - occlDepth;\n            shadow += float(diff <= 0.0);\n        }\n\n        shadow *= RCP_NUM_SHADOW_SAMPLES;\n        #else\n            float occlDepth = RGBA8ToFloat(texture2D(shadowMap, shadowCoord.xy));\n            float diff = shadowCoord.z - occlDepth;\n            float shadow = float(diff <= 0.0);\n        #endif\n    #endif\n\n    #ifdef VSM_SHADOW_MAP\n\n// the moments seem correct on ipad... why do the calculations differ?\n        vec2 moments = getVSMMoments(shadowCoord.xy);\n        float p = linearStep(shadowCoord.z - 0.02, shadowCoord.z, moments.x);\n        float variance = moments.y - moments.x * moments.x;\n        variance = max(variance, MIN_VARIANCE);\n\n        float diff = shadowCoord.z - moments.x;\n        float upperBound = variance / (variance + diff*diff);\n        float shadow = linearStep(LIGHT_BLEED_REDUCTION, 1.0, upperBound);\n        shadow = clamp(max(shadow, p), 0.0, 1.0);\n    #endif\n\n    vec2 edges = abs(shadowCoord.xy * 2.0 - 1.0);\n    float edge = max(edges.x, edges.y);\n    edge = linearStep(.8, 1.0, edge);\n    shadow = mix(shadow, 1.0, edge);\n    return shadow;\n#else\n    return 1.0;\n#endif\n}\n\nfloat fresnel(float NdotL, float lowProfileDefault)\n{\n#ifdef PERFORMANCE_PROFILE_HIGH\n// angle to the power of 5\n    float angle = 1.0 - NdotL;\n    float fresnelFactor = angle * angle;\n    fresnelFactor *= fresnelFactor;\n    fresnelFactor *= angle;\n    return normalSpecularReflection + (1.0 - normalSpecularReflection) * fresnelFactor;\n#else\n    return lowProfileDefault;\n#endif\n}\n\nfloat trowbridgeReitz(float roughnessSqr, vec3 lightDir, vec3 normal, vec3 viewDir)\n{\n    vec3 halfVec = normalize(lightDir + viewDir);\n    float micro = max(dot(halfVec, normal), 0.0);\n    float denom = (micro * micro) * (roughnessSqr - 1.0) + 1.0;\n    return roughnessSqr / (denom * denom);\n}\n\nvoid accumulate(vec3 lightDir, vec3 lightColor, vec3 normal, vec3 viewDir, float roughnessSqr, out vec3 diffuseLight, out vec3 specularLight)\n{\n    float NdotL = max(dot(lightDir, normal), 0.0);\n    vec3 irradiance = lightColor * NdotL;\n    diffuseLight += irradiance;\n\n#ifndef IGNORESPECULAR\n    float F = fresnel(NdotL, .08);\n    float D = trowbridgeReitz(roughnessSqr, lightDir, normal, viewDir);\n    float amount = D * F;\n\n    specularLight += irradiance * amount;\n#endif\n}\n\nvoid main() {\n    float roughnessSqr = roughness;\n    #ifdef ROUGHNESS_MAP\n    roughnessSqr -= (texture2D(roughnessMap, texCoords).x - .5) * roughnessMapRange;\n    roughnessSqr = clamp(roughnessSqr, 0.0, 1.0);\n    #endif\n    roughnessSqr *= roughnessSqr;\n    vec3 viewWorldDir = normalize(worldPosition - cameraPosition);\n    vec3 viewDir = -normalize(viewPosition);\n\n    vec3 normal = getNormal();\n    vec3 viewNormal = mat3(viewMatrix) * normal;\n\n    vec3 albedo = vec3(1.0);\n\n#ifdef ALBEDO_MAP\n    albedo = texture2D(albedoMap, texCoords).xyz;\n    albedo *= albedo;\n\n    #ifdef ALBEDO_MAP_2\n        vec3 albedo2 = texture2D(albedoMap2, texCoords).xyz;\n        albedo = mix(albedo, albedo2 * albedo2, albedoBlend);\n    #endif\n#endif\n\n    albedo *= color;\n\n    vec3 diffuseLight = vec3(0.0);\n\n    #ifdef IRRADIANCE_PROBE\n        vec4 diffuseSample = textureCube(irradianceProbe, normal);\n        diffuseLight = decodeHDRE(diffuseSample);\n\n        diffuseLight *= diffuseLight * irradianceProbeBoost;\n    #endif\n\n    float ao = 1.0;\n    #ifdef AMBIENT_OCCLUSION_MAP\n        ao = texture2D(aoMap, texCoords2).x;\n    #endif\n\n    #ifdef SSAO_MAP\n        vec2 screenUV = projection.xy / projection.w * .5 + .5;\n        ao = texture2D(ssaoMap, screenUV).x;\n    #endif\n\n    diffuseLight += ambientLightColor;\n    #ifndef AO_ON_DIFFUSE\n    diffuseLight *= ao;\n    #endif\n\n    vec3 specularLight = vec3(0.0);\n\n    #ifdef SPECULAR_PROBE\n        vec3 reflectedView = reflect(viewWorldDir, normal);\n        float fresnelFactor = fresnel(max(dot(viewWorldDir, normal), 0.0), .35);\n\n        #ifdef LOCAL_SKYBOX\n            vec3 offsetRefl = intersectCubeMap(worldPosition - skyboxPosition, reflectedView, skyboxSize);\n        #else\n            vec3 offsetRefl = reflectedView;\n        #endif\n\n        vec4 reflectionSample = textureCube(specularProbe, reflectedView);\n        vec3 reflection;\n\n        reflection = decodeHDRE(reflectionSample);\n\n        reflection *= reflection * specularProbeColor;\n\n        specularLight = reflection * fresnelFactor;\n\n        #ifdef AMBIENT_OCCLUSION_MAP\n//        specularLight *= ao;\n        #endif\n    #endif\n\n    #if NUM_POINT_LIGHTS > 0\n    for (int i = 0; i < NUM_POINT_LIGHTS; ++i) {\n        vec3 worldDir = pointLights[i].position - worldPosition;\n        float sqrDist = dot(worldDir, worldDir);\n        worldDir /= sqrt(sqrDist);\n        vec3 fallOffColor = pointLights[i].color / max(sqrDist, .001);\n        accumulate(worldDir, fallOffColor, normal, viewDir, roughnessSqr, diffuseLight, specularLight);\n    }\n    #endif\n\n    float shadow = getShadow();\n\n    #if NUM_DIR_LIGHTS > 0\n    for (int i = 0; i < NUM_DIR_LIGHTS; ++i) {\n        float NdotL = max(dot(directionalLights[i].direction, viewNormal), 0.0);\n        vec3 irradiance = directionalLights[i].color * NdotL;\n        irradiance *= shadow;\n        diffuseLight += irradiance;\n\n        #ifndef IGNORESPECULAR\n        float F = fresnel(NdotL, .04);\n        float D = trowbridgeReitz(roughnessSqr, directionalLights[i].direction, viewNormal, viewDir);\n        float amount = D * F;\n\n        specularLight += irradiance * amount;\n        #endif\n    }\n    #endif\n\n    #ifdef AO_ON_DIFFUSE\n    diffuseLight *= ao;\n    #endif\n\n    vec3 color = albedo * diffuseLight + specularLight;\n\n    vec3 emission = emissionColor;\n    #ifdef EMISSION_MAP\n    vec3 emissionSample = texture2D(emissionMap, texCoords).xyz;\n    emissionSample *= emissionSample;\n    emission *= emissionSample;\n    #endif\n    color += emission;\n\n    #ifdef FOG\n        float fogAmount = clamp(exp2(viewPosition.z * fogDensity), 0.0, 1.0);\n        vec3 fogCol = fogColor;\n        #ifdef FOG_PROBE\n            vec4 fogSample = textureCube(fogProbe, vec3(viewWorldDir.x , 0.0, viewWorldDir.z));\n            fogSample.xyz = decodeHDRE(fogSample);\n            fogSample.xyz *= fogSample.xyz * fogProbeBoost;\n            fogCol *= fogSample.xyz;\n        #endif\n        color = mix(fogCol, color, fogAmount);\n\n// ONLY FOR THIS PROJECT, this provides a fade-out for the horizon\n        fogAmount = smoothstep(100.0, 250.0, length(worldPosition.xz));\n        color = mix(color, fogCol, fogAmount);\n    #endif\n\n\n    gl_FragColor = encodeHDRE(sqrt(color));\n//    gl_FragColor = vec4(shadow);\n}\n",
  ShaderLibrary["dielectric_vertex.glsl"] = "varying vec3 worldPosition;\nvarying vec3 viewPosition;\nvarying vec3 worldNormal;\n\n#if defined(SSAO_MAP) || defined(ALBEDO_MAP) || defined(NORMAL_MAP) || defined(ROUGHNESS_MAP) || defined(EMISSION_MAP)\nvarying vec2 texCoords;\n#endif\n\n#if defined(AMBIENT_OCCLUSION_MAP)\nattribute vec2 uv2;\n\nvarying vec2 texCoords2;\n#endif\n\n#ifdef SSAO_MAP\nvarying vec4 projection;\n#endif\n\n#ifdef SHADOW_MAP\nuniform mat4 shadowMatrix;\n\nvarying vec4 shadowCoord;\n#endif\n\n#ifdef DISPLACEMENT_MAP\nuniform sampler2D displacementMap;\nuniform float displacementMapRange;\n#endif\n\nvoid main() {\n    vec3 norm = normalize(normal);\n    vec4 localPos = vec4(position, 1.0);\n    #ifdef DISPLACEMENT_MAP\n    vec2 invUV = uv;\n    invUV.y = 1.0 - invUV.y;\n    float displ = (texture2D(displacementMap, invUV).x - .5) * displacementMapRange;\n    localPos.xyz += norm * displ;\n    #endif\n\n    worldPosition = (modelMatrix * localPos).xyz;\n    // normalMatrix seems to be view space... need world space, but it's okay since we're using uniform scaling only\n    vec4 viewPos = modelViewMatrix * localPos;\n    worldNormal = mat3(modelMatrix) * norm;\n    gl_Position = projectionMatrix * viewPos;\n    viewPosition = viewPos.xyz;\n\n    #if defined(SSAO_MAP) || defined(ALBEDO_MAP) || defined(NORMAL_MAP) || defined(ROUGHNESS_MAP) || defined(EMISSION_MAP)\n    texCoords = uv;\n    #endif\n\n    #if defined(AMBIENT_OCCLUSION_MAP)\n    texCoords2 = uv2;\n    #endif\n\n    #ifdef SSAO_MAP\n    projection = gl_Position;\n    #endif\n\n    #ifdef SHADOW_MAP\n    shadowCoord = (shadowMatrix * vec4(worldPosition, 1.0)) * .5 + .5;\n    #endif\n\n    #ifdef AO_MAP\n    texCoords2 = uv2;\n    #endif\n}",
  ShaderLibrary["glass_fragment.glsl"] = "varying vec3 worldPosition;\nvarying vec3 viewPosition;\nvarying vec3 worldNormal;\n\nuniform float roughness;\nuniform float normalSpecularReflection;\n\n#ifdef SPECULAR_PROBE\nuniform samplerCube specularProbe;\n#endif\n\n#if NUM_POINT_LIGHTS > 0\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float distance;\n    float decay;\n    int shadow;\n    float shadowBias;\n    float shadowRadius;\n    vec2 shadowMapSize;\n};\n\nuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n#endif\n\n#if NUM_DIR_LIGHTS > 0\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n    int shadow;\n    float shadowBias;\n    float shadowRadius;\n    vec2 shadowMapSize;\n};\nuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n#endif\n\nvec3 getNormal()\n{\n    return normalize(worldNormal);\n}\n\nfloat fresnel(float NdotL)\n{\n// angle to the power of 5\n    float angle = 1.0 - NdotL;\n    float fresnelFactor = angle * angle;\n    fresnelFactor *= fresnelFactor;\n    fresnelFactor *= angle;\n    return normalSpecularReflection + (1.0 - normalSpecularReflection) * fresnelFactor;\n}\n\nfloat trowbridgeReitz(float roughnessSqr, vec3 lightDir, vec3 normal, vec3 viewDir)\n{\n    vec3 halfVec = normalize(lightDir + viewDir);\n    float micro = max(dot(halfVec, normal), 0.0);\n    float denom = (micro * micro) * (roughnessSqr - 1.0) + 1.0;\n    return roughnessSqr / (denom * denom);\n}\n\nvec3 accumulate(vec3 lightDir, vec3 lightColor, vec3 normal, vec3 viewDir, float roughnessSqr)\n{\n    float NdotL = max(dot(lightDir, normal), 0.0);\n    vec3 irradiance = lightColor * NdotL;\n\n    float F = fresnel(NdotL);\n    float D = trowbridgeReitz(roughnessSqr, lightDir, normal, viewDir);\n    float amount = D * F;\n\n    return irradiance * amount;\n}\n\nvoid main() {\n    float roughnessSqr = roughness * roughness;\n    vec3 viewDir = -normalize(viewPosition);\n\n    vec3 normal = getNormal();\n    vec3 viewNormal = mat3(viewMatrix) * normal;\n\n    vec3 specularLight = vec3(0.0);\n\n    #ifdef SPECULAR_PROBE\n        vec3 viewWorldDir = normalize(cameraPosition - worldPosition);\n        vec3 reflectedView = -reflect(viewWorldDir, normal);\n        float fresnelFactor = fresnel(max(dot(viewWorldDir, normal), 0.0));\n\n        vec3 reflection = textureCube(specularProbe, reflectedView).xyz;\n\n        specularLight += reflection * reflection * fresnelFactor;\n    #endif\n\n    #if NUM_POINT_LIGHTS > 0\n    for (int i = 0; i < NUM_POINT_LIGHTS; ++i) {\n        vec3 worldDir = pointLights[i].position - worldPosition;\n        float sqrDist = dot(worldDir, worldDir);\n        worldDir /= sqrt(sqrDist);\n        vec3 fallOffColor = pointLights[i].color / max(sqrDist, .001);\n        specularLight += accumulate(worldDir, fallOffColor, normal, viewDir, roughnessSqr);\n    }\n    #endif\n\n    #if NUM_DIR_LIGHTS > 0\n    for (int i = 0; i < NUM_DIR_LIGHTS; ++i) {\n        float NdotL = max(dot(directionalLights[i].direction, viewNormal), 0.0);\n        vec3 irradiance = directionalLights[i].color * NdotL;\n\n        float F = fresnel(NdotL);\n        float D = trowbridgeReitz(roughnessSqr, directionalLights[i].direction, viewNormal, viewDir);\n        float amount = D * F;\n\n        specularLight += irradiance * amount;\n    }\n    #endif\n\n    vec3 color = specularLight;\n\n    gl_FragColor.xyz = sqrt(color);\n    gl_FragColor.w = 1.0;\n}\n",
  ShaderLibrary["glass_vertex.glsl"] = "varying vec3 worldPosition;\nvarying vec3 viewPosition;\nvarying vec3 worldNormal;\n\nvoid main() {\n    worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n    // normalMatrix seems to be view space... need world space, but it's okay since we're using uniform scaling only\n    vec4 viewPos = modelViewMatrix * vec4(position,1.0);\n    worldNormal = mat3(modelMatrix) * normalize(normal);\n    gl_Position = projectionMatrix * viewPos;\n    viewPosition = viewPos.xyz;\n}",
  ShaderLibrary["linear_depth_fragment.glsl"] = "varying float linearDepth;\n\n// Only for 0 - 1\nvec4 hx_floatToRGBA8(float value)\n{\n    vec4 enc = value * vec4(1.0, 255.0, 65025.0, 16581375.0);\n    // cannot fract first value or 1 would not be encodable\n    enc.yzw = fract(enc.yzw);\n    return enc - enc.yzww * vec4(1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n}\n\nvoid main()\n{\n    gl_FragColor = hx_floatToRGBA8(linearDepth);\n}\n",
  ShaderLibrary["linear_depth_vertex.glsl"] = "varying float linearDepth;\n\nuniform float cameraNear;\nuniform float rcpCameraRange;\n\nvoid main()\n{\n    vec4 viewPosition = modelViewMatrix * vec4(position, 1.0);\n    linearDepth = (-viewPosition.z - cameraNear) * rcpCameraRange;\n    gl_Position = projectionMatrix * viewPosition;\n}",
  ShaderLibrary["render_volume_fragment.glsl"] = "struct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n    int shadow;\n    float shadowBias;\n    float shadowRadius;\n    vec2 shadowMapSize;\n};\n\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float distance;\n    float decay;\n    int shadow;\n    float shadowBias;\n    float shadowRadius;\n    vec2 shadowMapSize;\n};\n\n\nvarying vec3 viewVector;\nvarying vec3 localViewDir;\nvarying vec3 viewWorldDir;\nvarying vec3 frustumVec;\n\nuniform sampler2D lightAccum;\n\nuniform sampler2D waterDepthMap;\nuniform sampler2D sceneDepthMap;\n\n#if NUM_DIR_LIGHTS > 0\nuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n#endif\n\n#if NUM_POINT_LIGHTS > 0\nuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n#endif\n\n#ifdef SKYBOX\nuniform samplerCube skybox;\n#endif\n\nuniform vec2 pixelSize;\nuniform vec3 numCells;\nuniform float cellSize;\nuniform mat4 viewMatrixInverse;\nuniform mat4 projectionMatrix;\nuniform vec3 absorption;\nuniform float cameraNear;\nuniform float cameraRange;\nuniform float transparencyFactor;\nuniform float roughness;\nuniform float normalSpecularReflection;\nuniform mat4 modelViewMatrixInverse;\nuniform vec3 mie;\n\nvec4 sampleData(vec3 pos)\n{\n    vec4 samp = sampleCellLinear(lightAccum, pos, numCells, cellSize);\n//    if (!isInsideFluidDomain(pos, numCells, cellSize))\n//        samp = vec4(0.0);\n    return samp;\n}\n\nfloat trowbridgeReitz(float roughnessSqr, vec3 lightDir, vec3 normal, vec3 viewDir)\n{\n    vec3 halfVec = normalize(lightDir + viewDir);\n    float micro = max(dot(halfVec, normal), 0.0);\n    float denom = (micro * micro) * (roughnessSqr - 1.0) + 1.0;\n    return roughnessSqr / (denom * denom);\n}\n\nfloat fresnel(float NdotL)\n{\n    float angle = 1.0 - NdotL;\n    float fresnelFactor = pow(angle, 5.0);\n    return normalSpecularReflection + (1.0 - normalSpecularReflection) * fresnelFactor;\n}\n\nvec3 getReflectedLight(DirectionalLight light, vec3 normal, vec3 viewDir)\n{\n    float D = trowbridgeReitz(roughness * roughness, light.direction, normal, viewDir);\n    float dot = max(dot(normal, light.direction), 0.0);\n    return D * fresnel(dot) * light.color;\n}\n\n\nvec3 getViewPos(vec2 uv)\n{\n    float depth = RGBA8ToFloat(texture2D(waterDepthMap, uv));\n    float z = depth * cameraRange + cameraNear;\n    return frustumVec * vec3(uv * 2.0 - 1.0, 1.0) * z;\n}\n\nvec3 getViewNormal(vec2 uv, vec3 viewPos)\n{\n    vec3 left = getViewPos(uv - vec2(pixelSize.x, 0.0));\n    vec3 right = getViewPos(uv + vec2(pixelSize.x, 0.0));\n    vec3 bottom = getViewPos(uv - vec2(0.0, pixelSize.y));\n    vec3 top = getViewPos(uv + vec2(0.0, pixelSize.y));\n    vec3 tanR = normalize(right - left);\n    vec3 tanT = normalize(top - bottom);\n    return normalize(cross(tanR, tanT));\n}\n\n\nvoid main()\n{\n    vec2 uv2d = gl_FragCoord.xy * pixelSize;\n\n    float depth = RGBA8ToFloat(texture2D(waterDepthMap, uv2d));\n    if (depth > .9) discard;\n\n    float sceneDepth = RGBA8ToFloat(texture2D(sceneDepthMap, uv2d));\n\n    float z = cameraNear + depth * cameraRange;\n    vec3 viewZNorm = -viewVector / viewVector.z;\n    vec4 viewPos = vec4(z * viewZNorm, 1.0);\n    vec3 rayPos = (modelViewMatrixInverse * viewPos).xyz;\n\n    // hide particles that end up outside the bounds\n    if (!isInsideFluidDomain(rayPos, numCells, cellSize)) discard;\n\n    float marchLen = distance(viewPos.xyz, viewVector);\n    float sampleDistance = marchLen / float(NUM_SAMPLES);\n    sampleDistance = max(sampleDistance, cellSize);\n\n    vec3 stepAbsorb = absorption * sampleDistance;\n    vec3 transmittance = exp(-stepAbsorb);  // at least SOME transmission to prevent ugly aliasing\n    vec3 color = vec3(0.0);\n\n    vec4 projected = projectionMatrix * viewPos;\n    projected /= projected.w;\n    gl_FragDepthEXT = projected.z * .5 + .5;\n\n    // transform to fluid space\n    vec3 rayStep = normalize(localViewDir) * sampleDistance;\n    vec4 startData = sampleCellLinear(lightAccum, rayPos, numCells, cellSize);\n    vec4 data = startData;\n\n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n        float dens = data.w;\n        vec3 light = data.xyz;\n        // of that light, only the following amount is transmitted (beer-lambert)\n        vec3 absorb = clamp(exp(-dens * stepAbsorb), 0.0, 1.0);\n\n        color += light * transmittance * dens;\n        transmittance *= absorb;\n\n        rayPos += rayStep;\n        data = sampleData(rayPos);\n    }\n\n    vec3 viewNormal = getViewNormal(uv2d, viewPos.xyz);\n    vec3 worldNormal = mat3(viewMatrixInverse) * viewNormal;\n    vec3 viewWorldDirNorm = normalize(viewWorldDir.xyz);\n\n    #ifdef SKYBOX\n    vec3 cube = textureCube(skybox, viewWorldDirNorm).xyz;\n    color.xyz += transmittance * cube * cube * mie;\n\n    vec3 reflect = reflect(viewWorldDirNorm, worldNormal);\n    vec3 reflSamp = textureCube(skybox, -reflect).xyz;\n\n    // we're using the start density to prevent overly strong reflections on drops (they have low density)\n    float fresnelFactor = fresnel(max(dot(reflect, worldNormal), 0.0)) * startData.w;\n    color.xyz = mix(color.xyz, reflSamp * reflSamp * (1.0 - roughness), fresnelFactor);\n    #endif\n\n    #if NUM_DIR_LIGHTS > 0\n        vec3 viewDir = -normalize(viewVector);\n        for (int i = 0; i < NUM_DIR_LIGHTS; ++i) {\n            color += getReflectedLight(directionalLights[i], viewNormal, viewDir);\n        }\n    #endif\n\n    float distToScene = (sceneDepth - depth) * cameraRange + .01;\n    gl_FragColor.xyz = sqrt(color);\n    float alpha = 1.0 - exp(-transparencyFactor * distToScene);\n    gl_FragColor.w = clamp(alpha, 0.0, 1.0);\n}",
  ShaderLibrary["render_volume_vertex.glsl"] = "varying vec3 viewVector;\nvarying vec3 viewWorldDir;\nvarying vec3 localViewDir;\nvarying vec3 frustumVec;\n\nuniform vec3 numCells;\nuniform mat4 modelViewMatrixInverse;\nuniform mat4 unprojectionMatrix;\n\nuniform float samplePlaneDistance;\n\n\n#if NUM_DIR_LIGHTS > 0\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n    int shadow;\n    float shadowBias;\n    float shadowRadius;\n    vec2 shadowMapSize;\n};\n\nuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n#endif\n\nvoid main()\n{\n    vec4 viewPos = modelViewMatrix * vec4(position, 1.0);\n    gl_Position = projectionMatrix * viewPos;\n\n    vec3 worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n\n    viewWorldDir = worldPosition - cameraPosition;\n\n    // since we're front-culling, this is the backside of the box, where\n    // the ray should STOP\n    viewVector = viewPos.xyz;\n    localViewDir = mat3(modelViewMatrixInverse) * viewVector;\n\n    vec4 unproj = unprojectionMatrix * vec4(1.0, 1.0, 1.0, 1.0);\n\n    frustumVec = unproj.xyz / unproj.w;\n    frustumVec /= -frustumVec.z;\n}",
  ShaderLibrary["sky_fragment.glsl"] = "varying vec3 worldViewDir;\n\nuniform samplerCube envMap;\nuniform vec3 color;\nuniform float invert;\n\nvoid main()\n{\n    vec3 elementDir = normalize(worldViewDir * invert);\n    gl_FragColor = textureCube(envMap, elementDir) * vec4(color, 1.0);\n}\n",
  ShaderLibrary["sky_vertex.glsl"] = "varying vec3 worldViewDir;\n\nvoid main() {\n    vec3 worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n    worldViewDir = worldPosition - cameraPosition;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
  ShaderLibrary["unlit_fragment.glsl"] = "#ifdef ALBEDO_MAP\nvarying vec2 texCoords;\nuniform sampler2D albedoMap;\n#endif\n\nuniform vec3 color;\nuniform float opacity;\n\n#ifdef FOG\nvarying vec3 viewPosition;\n\nuniform float fogDensity;\nuniform vec3 fogColor;\n#endif\n\nvoid main() {\n    float alpha = opacity;\n#ifdef ALBEDO_MAP\n    vec4 albedo = texture2D(albedoMap, texCoords);\n    alpha *= albedo.w;\n    albedo.xyz *= albedo.xyz;\n    albedo.xyz *= color;\n    vec3 col = albedo.xyz;\n#else\n    vec3 col = color;\n#endif\n\n    #ifdef FOG\n    float fogAmount = clamp(exp2(viewPosition.z * fogDensity), 0.0, 1.0);\n    col = mix(fogColor, col, fogAmount);\n    #endif\n\n    #ifdef HDRE\n    gl_FragColor = encodeHDRE(sqrt(col));\n    #else\n//    col *= alpha;\n    gl_FragColor = vec4(sqrt(col), alpha);\n    #endif\n}\n",
  ShaderLibrary["unlit_vertex.glsl"] = "#ifdef ALBEDO_MAP\nvarying vec2 texCoords;\n#endif\n\n#ifdef FOG\nvarying vec3 viewPosition;\n#endif\n\nvoid main() {\n    vec3 localPos = position;\n    vec4 viewPos = modelViewMatrix * vec4(localPos, 1.0);\n    gl_Position = projectionMatrix * viewPos;\n    #ifdef FOG\n    viewPosition = viewPos.xyz;\n    #endif\n\n    #ifdef ALBEDO_MAP\n    texCoords = uv;\n    #endif\n}",
  ShaderLibrary["volumetric_lighting_fragment.glsl"] = "varying vec2 texCoords;\n\nuniform sampler2D densityField;\nuniform samplerCube irradiance;\nuniform vec3 numCells;\nuniform vec3 absorption;\nuniform vec3 cameraPos;\nuniform float sampleStep;\nuniform float cellSize;\nuniform vec3 mieG;\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n    int shadow;\n    float shadowBias;\n    float shadowRadius;\n    vec2 shadowMapSize;\n};\n\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float distance;\n    float decay;\n    int shadow;\n    float shadowBias;\n    float shadowRadius;\n    vec2 shadowMapSize;\n};\n\n#if NUM_DIR_LIGHTS > 0\nuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n#endif\n\n#if NUM_POINT_LIGHTS > 0\nuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n#endif\n\n\n// does this contain anything useful?\n// http://orbit.dtu.dk/files/5501107/paper.pdf\nvec3 mieFactor(vec3 lightDir, vec3 viewDir)\n{\n    float cosAng = dot(lightDir, viewDir);\n    vec3 num = vec3(1.0) - mieG;\n    vec3 p = vec3(1.0) + mieG*mieG - 2.0 * mieG * cosAng;\n    p.x = pow(p.x, 1.5);\n    p.y = pow(p.y, 1.5);\n    p.z = pow(p.z, 1.5);\n    return num * num / (4.0 * PI * p);\n}\n\nfloat sampleDensity(vec3 pos)\n{\n    vec4 samp = sampleCellLinear(densityField, pos, numCells, cellSize);\n    #ifdef WATER\n        samp.x = samp.x < 0.0? 1.0 : 0.0;\n    #endif\n    return isInsideFluidDomain(pos, numCells, cellSize)? samp.x : 0.0;\n}\n\nvec3 getTransmittedLight(vec3 pos, DirectionalLight light, vec3 viewDir)\n{\n    float amount = 0.0;\n    vec3 marchStep = light.direction * sampleStep;\n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n        amount += sampleDensity(pos);\n        pos += marchStep;\n    }\n\n    vec3 mie = mieFactor(light.direction, viewDir);\n\n    return exp(-amount * absorption * sampleStep) * light.color * mie;\n}\n\nvec3 getTransmittedLight(vec3 pos, PointLight light, vec3 viewDir, vec3 localPos)\n{\n    float amount = 0.0;\n    vec3 lightDir = light.position - localPos;\n    float len = length(lightDir);\n    float step = min(len / float(NUM_SAMPLES), sampleStep);\n    lightDir = normalize(lightDir);\n    vec3 marchStep = lightDir * step;\n\n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n        pos += marchStep;\n        amount += sampleDensity(pos);\n    }\n\n    vec3 mie = mieFactor(lightDir, viewDir);\n\n// pretend the light has some sort of size\n//    len = max(len, 10.0);\n    return exp(-amount * absorption * step) * mie * light.color / (len * len);\n}\n\nvec3 getGlobalIllum()\n{\n    float occlStrength = .1;\n    float sampleDist = 2.0;\n    vec2 rcpTexSize = vec2(1.0 / (numCells.x * numCells.z), 1.0 / numCells.y) * sampleDist;\n    float right = texture2D(densityField, texCoords + vec2(rcpTexSize.x, 0.0)).x;\n    float left = texture2D(densityField, texCoords - vec2(rcpTexSize.x, 0.0)).x;\n    float top = texture2D(densityField, texCoords + vec2(0.0, rcpTexSize.y)).x;\n    float bottom = texture2D(densityField, texCoords - vec2(0.0, rcpTexSize.y)).x;\n    float far = texture2D(densityField, texCoords + vec2(sampleDist/numCells.z, 0.0)).x;\n    float near = texture2D(densityField, texCoords - vec2(sampleDist/numCells.z, 0.0)).x;\n    // use the inverse gradient as the hint of direction where most light comes from (similar to bent normals)\n    vec3 grad = -normalize(vec3(right - left, top - bottom, far - near));\n    right = clamp(right * occlStrength, 0.0, 1.0);\n    left = clamp(left * occlStrength, 0.0, 1.0);\n    top = clamp(top * occlStrength, 0.0, 1.0);\n    bottom = clamp(bottom * occlStrength, 0.0, 1.0);\n    far = clamp(far * occlStrength, 0.0, 1.0);\n    near = clamp(near * occlStrength, 0.0, 1.0);\n\n    float occl = (6.0 - right - left - top - bottom - far - near) / 6.0;\n    vec3 cube = textureCube(irradiance, grad).xyz;\n    return cube * cube * occl;\n}\n\nvoid main() {\n    vec4 data = texture2D(densityField, texCoords);\n    vec3 localPos = getCellPosition(texCoords, numCells, cellSize);\n    vec3 color = vec3(0.0);\n    vec3 viewDir = normalize(cameraPos - localPos);\n\n    #if NUM_DIR_LIGHTS > 0\n        for (int i = 0; i < NUM_DIR_LIGHTS; ++i) {\n            color += getTransmittedLight(localPos, directionalLights[i], viewDir);\n        }\n    #endif\n\n    #if NUM_POINT_LIGHTS > 0\n        for (int i = 0; i < NUM_POINT_LIGHTS; ++i) {\n            color += getTransmittedLight(localPos, pointLights[i], viewDir, localPos);\n        }\n    #endif\n\n    #ifndef WATER\n    color += getGlobalIllum() * clamp(data.x, 0.0, 1.0);\n    #endif\n\n    gl_FragColor.xyz = color;\n\n    #ifdef WATER\n//        gl_FragColor.w = smoothstep(0.0, -0.001, data.x);\n        gl_FragColor.w = data.x < 0.0? 1.0 : 0.0;\n    #else\n        gl_FragColor.w = data.x;\n    #endif\n}",
  ShaderLibrary["volumetric_normals_fragment.glsl"] = "varying vec2 texCoords;\n\nuniform sampler2D densityField;\nuniform vec2 rcpTexSize;\nuniform vec3 numCells;\n\nfloat sampleDensity(vec2 texCoord)\n{\n    vec4 samp = texture2D(densityField, texCoord);\n    return samp.x;\n}\n\nvoid main() {\n    float right = sampleDensity(texCoords + vec2(rcpTexSize.x, 0.0));\n    float left = sampleDensity(texCoords - vec2(rcpTexSize.x, 0.0));\n    float top = sampleDensity(texCoords + vec2(0.0, rcpTexSize.y));\n    float bottom = sampleDensity(texCoords - vec2(0.0, rcpTexSize.y));\n    float far = sampleDensity(texCoords + vec2(1.0/numCells.z, 0.0));\n    float near = sampleDensity(texCoords - vec2(1.0/numCells.z, 0.0));\n    // use the inverse gradient as the hint of direction where most light comes from (similar to bent normals)\n    vec3 grad = vec3(right - left, top - bottom, far - near);\n    grad /= max(length(grad), 0.001);\n    gl_FragColor = vec4(-grad * .5 + .5, 1.0);\n}",
  ShaderLibrary["volumetric_vertex.glsl"] = "varying vec2 texCoords;\n\nvoid main() {\n    gl_Position = vec4(position, 1.0);\n    texCoords = uv;\n}\n",
  ShaderLibrary["include_sph.glsl"] = "#define PI 3.141592\n\nstruct Collision {\n    bool collided;\n    vec3 normal;\n    vec3 point;\n//    float d;\n};\n\nvec2 getBucketUV(vec3 position, vec3 numCells, float cellSize)\n{\n    // map position to actual cell\n    position = position / cellSize + numCells * .5;\n    vec2 uv = (position.xy + vec2(.5)) / vec2(numCells.x * numCells.z, numCells.y);\n    uv.x += floor(position.z + .5) / numCells.z;\n    return uv;\n}\n\nvec2 getParticleBufferUV(float particleIndex, vec2 texSize)\n{\n    particleIndex -= 1.0;\n    vec2 uv;\n    uv.y = floor(particleIndex / texSize.x);\n    uv.x = particleIndex - uv.y * texSize.x;\n    return (uv + vec2(.5)) / texSize;\n}\n\n// the uv coord in the particle rect texture\nvec4 sampleParticleData(sampler2D tex, float particleIndex, vec2 texSize)\n{\n    vec2 uv = getParticleBufferUV(particleIndex, texSize);\n    return texture2D(tex, uv);\n}\n\nvec4 sampleCellPoint(sampler2D tex, vec3 pos, vec3 numCells, float cellSize)\n{\n    pos = pos / cellSize + numCells * .5;\n    vec2 uv;\n    uv.xy = pos.xy / vec2(numCells.x * numCells.z, numCells.y);\n    uv.x += pos.z / numCells.z;\n    return texture2D(tex, uv);\n}\n\nvec4 sampleCellLinear(sampler2D tex, vec3 pos, vec3 numCells, float cellSize)\n{\n    vec2 uv;\n    pos = pos / cellSize + numCells * .5;\n    uv.xy = pos.xy / vec2(numCells.x * numCells.z, numCells.y);\n    float flZ = floor(pos.z);\n    uv.x += flZ / numCells.z;\n\n    vec4 val1 = texture2D(tex, uv);\n    uv.x += 1.0 / numCells.z;\n    vec4 val2 = texture2D(tex, uv);\n\n    return mix(val1, val2, pos.z - flZ);\n}\n\nbool isInsideFluidDomain(vec3 pos, vec3 numCells, float cellSize)\n{\n    vec3 he = (numCells * .5) * cellSize;\n    bvec3 g = greaterThanEqual(pos, -he);\n    bvec3 l = lessThanEqual(pos, he);\n    return all(g) && all(l);\n}\n\nvec3 getCellPosition(vec2 uv, vec3 numCells, float cellSize)\n{\n    vec3 cell;\n    // coordinates in cell coords (cell Y matches pixel Y)\n    cell.xy = uv * vec2(numCells.x * numCells.z, numCells.y);\n    cell.z = floor(cell.x / numCells.x);\n    cell.x -= cell.z * numCells.x;\n    cell -= numCells * .5;\n    return cell * cellSize;\n}\n\nvec3 getCellPositionFromFragCoord(vec2 fragCoord, vec3 numCells, float cellSize)\n{\n    vec3 cell;\n    // coordinates in cell coords (cell Y matches pixel Y)\n    cell.xy = fragCoord;\n    cell.z = floor(cell.x / numCells.x);\n    cell.x -= cell.z * numCells.x;\n    cell -= numCells * .5;\n    return cell * cellSize;\n}",
  ShaderLibrary["sph_accel_fragment.glsl"] = "uniform sampler2D bucketBuffer;\nuniform sampler2D positionBuffer;\nuniform sampler2D densityBuffer;\nuniform sampler2D velocityBuffer;\n\nvarying vec2 texCoords;\n\nuniform vec3 numCells;\nuniform vec2 particleBufferSize;\nuniform vec2 bucketPixelSize;\nuniform float cellSize;\nuniform float gravity;\nuniform float h;\nuniform float h2;\nuniform float pressNorm;\nuniform float viscNorm;\nuniform float surfaceNorm;\nuniform float viscosity;\nuniform float stiffness;\nuniform float restDensity;\nuniform float mass;\nuniform float drag;\nuniform float dt;\nuniform float curvatureThreshold;\nuniform float surfaceTension;\nuniform float maxParticleIndex;\n\nfloat pressure(float density)\n{\n    // rest density is there to cause attraction when density is too low\n    return stiffness * (density - restDensity);\n}\n\n// all these contributions have mass removed from them, as it's constant we add it later\n\nvec3 getPressContrib(vec3 R_ij, float dist, float p_i, float rho_j)\n{\n    float p_j = pressure(rho_j);\n    float d = max(h - dist, 0.0);\n    vec3 gradW = pressNorm * d * d * normalize(R_ij);\n    return -(p_i + p_j) * .5 /**  mass *// rho_j * gradW;\n}\n\nvec3 getViscContrib(vec3 R_ij, float dist, vec3 v_i, vec3 v_j, float rho_j)\n{\n    float diff = max(h - dist, 0.0);\n    float laplW = viscNorm * diff;\n    return (v_j - v_i) /** mass *// rho_j * laplW;\n}\n\nvec3 getGradColContrib(vec3 R_ij, float dist, float rho_j)\n{\n    float d = max(h2 - dist * dist, 0.0);\n    vec3 gradW = surfaceNorm * R_ij * d * d;\n    return gradW /** mass*/ / rho_j;\n}\n\nfloat getLaplaceColContrib(vec3 R_ij, float dist, float rho_j)\n{\n    float d1 = max(h2 - dist * dist, 0.0);\n    float d2 = 3.0 * h2 - 7.0 * dist * dist;\n    float laplW = surfaceNorm * d1 * d2;\n    return laplW /** mass *// rho_j;\n}\n\nvoid main() {\n    vec4 posSample = texture2D(positionBuffer, texCoords);\n    vec3 v_i = texture2D(velocityBuffer, texCoords).xyz;\n    vec3 x_i = posSample.xyz;\n    float rho_i = texture2D(densityBuffer, texCoords).x;\n    float p_i = pressure(rho_i);\n    float thisIndex = posSample.w;\n\n    vec3 Fpress = vec3(0.0);\n    vec3 Fvisc = vec3(0.0);\n\n    vec2 bucketUV = getBucketUV(x_i, numCells, cellSize);\n\n    vec3 normal = vec3(0.0);\n    float laplCol = 0.0;\n\n    for (int z = -SAMPLE_RADIUS; z <= SAMPLE_RADIUS; ++z) {\n        for (int y = -SAMPLE_RADIUS; y <= SAMPLE_RADIUS; ++y) {\n            for (int x = -SAMPLE_RADIUS; x <= SAMPLE_RADIUS; ++x) {\n                vec2 uvNeigh = bucketUV + vec2(x, y) * bucketPixelSize;\n                uvNeigh.x += float(z) / numCells.z;\n                vec4 partIndices = texture2D(bucketBuffer, uvNeigh);\n\n                for (int p = 0; p < 4; ++p) {\n                    float index = partIndices[p];\n\n                    if (index > 0.0 && thisIndex != index) {\n                        vec2 uv = getParticleBufferUV(index, particleBufferSize);\n                        vec3 x_j = texture2D(positionBuffer, uv).xyz;\n                        vec3 v_j = texture2D(velocityBuffer, uv).xyz;\n                        float rho_j = texture2D(densityBuffer, uv).x;\n                        vec3 R_ij = x_i - x_j;\n                        float dist = length(R_ij);\n                        Fpress += getPressContrib(R_ij, dist, p_i, rho_j);\n                        Fvisc += getViscContrib(R_ij, dist, v_i, v_j, rho_j);\n                        normal += getGradColContrib(R_ij, dist, rho_j);\n                        laplCol += getLaplaceColContrib(R_ij, dist, rho_j);\n                    }\n                }\n            }\n        }\n    }\n\n    laplCol *= mass;\n    normal *= mass;\n    Fpress *= mass;\n    Fvisc *= mass;\n\n    vec3 Fsurface = vec3(0.0);\n    float normalLen = length(normal);\n    if (normalLen > curvatureThreshold) {\n        float curvature = -laplCol / normalLen;\n        Fsurface = surfaceTension * curvature * normal / normalLen;\n    }\n\n    vec3 dragAccell = -v_i * drag;\n    vec3 F = viscosity * Fvisc + Fpress + Fsurface;\n    vec3 a_i = F / rho_i;\n    a_i.y += gravity;\n    a_i += dragAccell;\n\n    if (thisIndex > maxParticleIndex)\n        a_i = vec3(0.0);\n\n    gl_FragColor.xyz = a_i;\n    gl_FragColor.w = 1.0;\n}\n\n",
  ShaderLibrary["sph_ball_collider_fragment.glsl"] = "uniform vec3 numCells;\nuniform vec3 wallExtent;\nuniform float cellSize;\nuniform vec3 spherePosition;\nuniform float sphereRadius;\n\nfloat getDistance(vec3 pos)\n{\n    float wallDist = signedDistanceWalls(pos, wallExtent);\n    float sphereDist = signedDistanceSphere(pos, spherePosition, sphereRadius);\n    return min(wallDist, sphereDist);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float r = getDistance(pos + vec3(cellSize, 0.0, 0.0));\n    float l = getDistance(pos - vec3(cellSize, 0.0, 0.0));\n    float t = getDistance(pos + vec3(0.0, cellSize, 0.0));\n    float b = getDistance(pos - vec3(0.0, cellSize, 0.0));\n    float n = getDistance(pos + vec3(0.0, 0.0, cellSize));\n    float f = getDistance(pos - vec3(0.0, 0.0, cellSize));\n\n    // normalization happens in collision test anyway, so no need for it here\n    return normalize(vec3(r - l, t - b, n - f));\n}\n\nvoid main() {\n    vec3 pos = getCellPositionFromFragCoord(gl_FragCoord.xy, numCells, cellSize);\n    float dist = getDistance(pos);\n    vec3 normal = getNormal(pos);\n\n    gl_FragColor = vec4(normal, dist);\n}\n",
  ShaderLibrary["sph_bucket_fragment.glsl"] = "varying float index;\nuniform float numParticles;\n\nvoid main() {\n    gl_FragColor = vec4(index);\n}\n",
  ShaderLibrary["sph_bucket_vertex.glsl"] = 'attribute vec2 positionUV;\nattribute float particleIndex;\n\nuniform sampler2D positionBuffer;\nuniform vec3 numCells;\nuniform float numParticles;\nuniform float cellSize;\n\nvarying float index;\n\nvoid main() {\n    vec4 localPos = vec4(texture2D(positionBuffer, positionUV).xyz, 1.0);\n    vec2 uv = getBucketUV(localPos.xyz, numCells, cellSize);\n\n    // write index to depth\n    gl_Position = vec4(uv * 2.0 - 1.0, particleIndex / numParticles * 2.0 - 1.0, 1.0);\n    gl_PointSize = 1.0;\n\n    // When reading, we assume 0 (clear value) means "no particle"\n    index = particleIndex + 1.0;\n}',
  ShaderLibrary["sph_density_fragment.glsl"] = "uniform sampler2D positionBuffer;\nuniform sampler2D collisionBuffer;\nuniform sampler2D bucketBuffer;\n\nvarying vec2 texCoords;\n\nuniform vec3 numCells;\nuniform float cellSize;\nuniform vec2 particleBufferSize;\nuniform vec2 bucketPixelSize;\nuniform float mass;\nuniform float h2;\nuniform float kernelNorm;\n\nfloat kernel(float dist2)\n{\n    // 6th degree polynomial kernel\n    float diff = max(h2 - dist2, 0.0);\n    return kernelNorm * pow(diff, 3.0);\n}\n\nvoid main() {\n    vec3 x_i = texture2D(positionBuffer, texCoords).xyz;\n\n    // when using half float texture, this messes up\n    float sum = 0.0;\n\n    vec2 bucketUV = getBucketUV(x_i, numCells, cellSize);\n    for (int z = -SAMPLE_RADIUS; z <= SAMPLE_RADIUS; ++z) {\n        for (int y = -SAMPLE_RADIUS; y <= SAMPLE_RADIUS; ++y) {\n            for (int x = -SAMPLE_RADIUS; x <= SAMPLE_RADIUS; ++x) {\n                vec2 uvNeigh = bucketUV + vec2(x, y) * bucketPixelSize;\n                uvNeigh.x += float(z) / numCells.z;\n                vec4 partIndices = texture2D(bucketBuffer, uvNeigh);\n\n                for (int p = 0; p < 4; ++p) {\n                    float index = partIndices[p];\n                    if (index > 0.0) {\n                        vec3 x_j = sampleParticleData(positionBuffer, index, particleBufferSize).xyz;\n                        vec3 r = x_i - x_j;\n                        float dist2 = dot(r, r);\n                        sum += kernel(dist2);\n                    }\n                }\n            }\n        }\n    }\n\n//    float wallDist = texture2D(collisionBuffer, bucketUV).w;\n//    sum += kernel(wallDist * wallDist) * 3.0;\n    sum *= mass;\n\n    gl_FragColor = vec4(sum, sum, sum, 1.0);\n}\n",
  ShaderLibrary["sph_distance_fragment.glsl"] = "varying vec3 particlePosition;\n\nuniform vec3 numCells;\nuniform float cellSize;\nuniform float particleRadius;\n\nvoid main() {\n    vec3 pos = getCellPositionFromFragCoord(gl_FragCoord.xy, numCells, cellSize);\n    // the * 10 is just so that interpolations find the edge quicker\n    float signedDist = distance(particlePosition, pos) - particleRadius * 100.0;\n    gl_FragColor = vec4(signedDist, 0.0, 0.0, 1.0);\n}\n",
  ShaderLibrary["sph_distance_vertex.glsl"] = "attribute vec2 positionUV;\n\nuniform sampler2D positionBuffer;\nuniform vec3 numCells;\nuniform float cellSize;\nuniform float particleRadius;\nuniform float zSliceOffset;\n\nvarying vec3 particlePosition;\n\nvoid main() {\n    vec4 localPos = vec4(texture2D(positionBuffer, positionUV).xyz, 1.0);\n    vec2 uv = getBucketUV(localPos.xyz, numCells, cellSize);\n    uv.x += zSliceOffset / numCells.z;\n\n    gl_Position = vec4(uv * 2.0 - 1.0, 0.0, 1.0);\n\n    float rad = cos(zSliceOffset * cellSize / particleRadius * PI * .5);\n    float pointSize = ceil(particleRadius / cellSize * 2.0 * rad) + 1.0;\n    gl_PointSize = pointSize;\n\n    particlePosition = localPos.xyz;\n}",
  ShaderLibrary["sph_heightmap_collider_fragment.glsl"] = "uniform vec3 wallExtent;\nuniform vec3 numCells;\nuniform float cellSize;\nuniform vec3 spherePosition;\nuniform float sphereRadius;\n\nuniform sampler2D heightMap;\n\nfloat getDistance(vec3 pos)\n{\n    float wallDist = signedDistanceWalls(pos, wallExtent);\n\n    // this is not entirely correct, but let's hope it's good enough\n    vec3 size = numCells * cellSize;\n    vec2 uv = pos.xz / size.xz + .5;\n    uv.y = 1.0 - uv.y;\n    float y =(texture2D(heightMap, uv).x - .5) * size.y;\n    float heightMapDist = pos.y - y;\n\n    return min(wallDist, heightMapDist);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float r = getDistance(pos + vec3(cellSize, 0.0, 0.0));\n    float l = getDistance(pos - vec3(cellSize, 0.0, 0.0));\n    float t = getDistance(pos + vec3(0.0, cellSize, 0.0));\n    float b = getDistance(pos - vec3(0.0, cellSize, 0.0));\n    float n = getDistance(pos + vec3(0.0, 0.0, cellSize));\n    float f = getDistance(pos - vec3(0.0, 0.0, cellSize));\n\n    // normalization happens in collision test anyway, so no need for it here\n    return normalize(vec3(r - l, t - b, n - f));\n}\n\nvoid main() {\n    vec3 pos = getCellPositionFromFragCoord(gl_FragCoord.xy, numCells, cellSize);\n    float dist = getDistance(pos);\n    vec3 normal = getNormal(pos);\n\n    gl_FragColor = vec4(normal, dist);\n}\n",
  ShaderLibrary["sph_init_velocity_still.glsl"] = "vec3 initVelocity(float index, vec3 numCells, float cellSize)\n{\n    return vec3(0.0);\n}",
  ShaderLibrary["sph_init_velocity_stream.glsl"] = "vec3 initVelocity(float index, vec3 numCells, float cellSize)\n{\n    return vec3(numCells.x, 0.0, numCells.y) * cellSize;\n}",
  ShaderLibrary["sph_particle_depth_fragment.glsl"] = "varying float radius;\nvarying vec2 centerFrag;\nvarying vec3 viewPosition;\n\nuniform float particleSize;\nuniform float cameraNear;\nuniform float rcpCameraRange;\nuniform mat4 projectionMatrix;\n\nvoid main() {\n    float radius2 = radius * radius;\n    vec2 diff = gl_FragCoord.xy - centerFrag;\n    diff /= radius;\n    float dist2 = dot(diff, diff);\n    if (dist2 > 1.0) discard;\n\n    vec3 normal;\n    normal.xy = diff;\n    normal.z = sqrt(1.0 - dist2);\n\n    vec3 pos = viewPosition - normal * particleSize;\n    float linearDepth = (-pos.z - cameraNear) * rcpCameraRange;\n\n    gl_FragColor = floatToRGBA8(linearDepth);\n    gl_FragDepthEXT = linearDepth;\n}\n",
  ShaderLibrary["sph_particle_depth_vertex.glsl"] = "attribute vec2 positionUV;\n\nuniform sampler2D positionBuffer;\nuniform float particleSize;\nuniform vec2 viewportSize;\n\nvarying float radius;\nvarying vec2 centerFrag;\nvarying vec3 viewPosition;\n\nvoid main() {\n    vec4 localPos = vec4(texture2D(positionBuffer, positionUV).xyz, 1.0);\n    vec4 viewPos = modelViewMatrix * localPos;\n    gl_Position = projectionMatrix * viewPos;\n    radius = -projectionMatrix[1][1] * particleSize / viewPos.z * viewportSize.y;\n    gl_PointSize = radius * 2.0;\n\n    centerFrag = (gl_Position.xy / gl_Position.w + 1.0) * viewportSize * .5;\n\n    viewPosition = viewPos.xyz;\n}",
  ShaderLibrary["sph_particle_point_fragment.glsl"] = "#ifdef MAP\nuniform sampler2D colorBuffer;\n\nvarying vec2 texCoords;\n#endif\n\nvoid main() {\n#ifdef MAP\n    gl_FragColor.xyz = (.5 + length(texture2D(colorBuffer, texCoords).xyz)) * vec3(.5, .8, 1.0) * .5;\n    gl_FragColor.w = 1.0;\n#else\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
  ShaderLibrary["sph_particle_point_vertex.glsl"] = "attribute vec2 positionUV;\n\nuniform sampler2D positionBuffer;\nuniform float particleSize;\n\n#ifdef MAP\nvarying vec2 texCoords;\n#endif\n\nvoid main() {\n    vec4 localPos = vec4(texture2D(positionBuffer, positionUV).xyz, 1.0);\n    vec4 viewPos = modelViewMatrix * localPos;\n    gl_Position = projectionMatrix * viewPos;\n    gl_PointSize = particleSize;\n\n    #ifdef MAP\n    texCoords = positionUV;\n    #endif\n\n}",
  ShaderLibrary["sph_position_fragment.glsl"] = "varying vec2 texCoords;\nuniform sampler2D velocityBuffer;\nuniform sampler2D positionBuffer;\nuniform sampler2D accelBuffer;\n\nuniform float dt;\nuniform vec3 wallExtent;\nuniform float maxParticleIndex;\n\nvoid main() {\n    vec4 posSample = texture2D(positionBuffer, texCoords);\n    vec3 a_i = texture2D(accelBuffer, texCoords).xyz;\n    vec3 v_i = texture2D(velocityBuffer, texCoords).xyz;\n    vec3 x_i = posSample.xyz;\n    float thisIndex = posSample.w;\n\n    vec3 x_i_1 = x_i + dt * (v_i + .5 * a_i * dt);\n\n//    x_i_1 = min(x_i_1, wallExtent);\n//    x_i_1 = max(x_i_1, -wallExtent);\n\n    if (thisIndex > maxParticleIndex)\n        x_i_1 = x_i;\n\n    gl_FragColor = vec4(x_i_1, thisIndex);\n}\n",
  ShaderLibrary["sph_quad_vertex.glsl"] = "varying vec2 texCoords;\n\nvoid main() {\n    texCoords = uv;\n    gl_Position = vec4(position, 1.0);\n}",
  ShaderLibrary["sph_velocity_fragment.glsl"] = "varying vec2 texCoords;\nuniform sampler2D positionBuffer;\nuniform sampler2D velocityBuffer;\nuniform sampler2D accelBuffer1;\nuniform sampler2D accelBuffer2;\nuniform sampler2D collisionBuffer;\n\nuniform float dt;\nuniform vec3 numCells;\nuniform float cellSize;\nuniform float restDistance;\nuniform float maxParticleIndex;\n\nvoid main() {\n    vec4 posSample = texture2D(positionBuffer, texCoords);\n    vec3 a_i = texture2D(accelBuffer1, texCoords).xyz;\n    vec3 a_i_p = texture2D(accelBuffer2, texCoords).xyz;\n    vec3 v_i = texture2D(velocityBuffer, texCoords).xyz;\n    vec3 x_i = posSample.xyz;\n    float thisIndex = posSample.w;\n\n    vec3 v_i_1 = v_i + dt * (a_i + a_i_p) * .5;\n\n    vec3 x_i_1 = x_i + v_i_1 * dt;\n    vec4 boundSample = sampleCellLinear(collisionBuffer, x_i_1, numCells, cellSize);\n    vec3 wallNormal = normalize(boundSample.xyz);\n    float wallDist = max(restDistance * 2.0 - boundSample.w, 0.0);\n    // move the particle back to the correct rest distance, this enforces no-slip condition on velocity\n    x_i_1 += wallDist * wallNormal;\n    // update the velocity to match\n    v_i_1 = (x_i_1 - x_i) / dt;\n\n    if (thisIndex > maxParticleIndex)\n        v_i_1 = initVelocity(thisIndex, numCells, cellSize);\n\n    gl_FragColor = vec4(v_i_1, 1.0);\n}\n",
  ShaderLibrary["sph_wall_collider_fragment.glsl"] = "uniform vec3 wallExtent;\nuniform vec3 numCells;\nuniform float cellSize;\n\nfloat getDistance(vec3 pos)\n{\n    return signedDistanceWalls(pos, wallExtent);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float r = getDistance(pos + vec3(cellSize, 0.0, 0.0));\n    float l = getDistance(pos - vec3(cellSize, 0.0, 0.0));\n    float t = getDistance(pos + vec3(0.0, cellSize, 0.0));\n    float b = getDistance(pos - vec3(0.0, cellSize, 0.0));\n    float n = getDistance(pos + vec3(0.0, 0.0, cellSize));\n    float f = getDistance(pos - vec3(0.0, 0.0, cellSize));\n\n    // normalization happens in collision test anyway, so no need for it here\n    return normalize(vec3(r - l, t - b, n - f));\n}\n\nvoid main() {\n    vec3 pos = getCellPositionFromFragCoord(gl_FragCoord.xy, numCells, cellSize);\n    float dist = getDistance(pos);\n    vec3 normal = getNormal(pos);\n\n    gl_FragColor = vec4(normal, dist);\n}\n"

export { ShaderLibrary }
